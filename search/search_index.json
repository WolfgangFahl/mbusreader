{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mbusreader API Documentation","text":""},{"location":"#mbusread.i18n","title":"<code>i18n</code>","text":"<p>Created on 2025-01-22</p> <p>@author: wf</p>"},{"location":"#mbusread.i18n.I18n","title":"<code>I18n</code>","text":"<p>Simple internationalization class for message handling</p> Source code in <code>mbusread/i18n.py</code> <pre><code>@lod_storable\nclass I18n:\n    \"\"\"Simple internationalization class for message handling\"\"\"\n\n    language: str = \"en\"\n    messages: Dict[str, Dict[str, str]] = field(default_factory=dict)\n\n    @classmethod\n    def default(cls) -&gt; \"I18n\":\n        yaml_file = MBusConfig.examples_path() + \"/i18n.yaml\"\n        i18n = cls.load_from_yaml_file(yaml_file)\n        return i18n\n\n    def get(self, key: str, *args) -&gt; str:\n        \"\"\"Get localized message with optional formatting\"\"\"\n        if self.language not in self.messages:\n            self.language = \"en\"\n        message = self.messages[self.language].get(key, key)\n        formatted_message = message.format(*args) if args else message\n        return formatted_message\n</code></pre>"},{"location":"#mbusread.i18n.I18n.get","title":"<code>get(key, *args)</code>","text":"<p>Get localized message with optional formatting</p> Source code in <code>mbusread/i18n.py</code> <pre><code>def get(self, key: str, *args) -&gt; str:\n    \"\"\"Get localized message with optional formatting\"\"\"\n    if self.language not in self.messages:\n        self.language = \"en\"\n    message = self.messages[self.language].get(key, key)\n    formatted_message = message.format(*args) if args else message\n    return formatted_message\n</code></pre>"},{"location":"#mbusread.logger","title":"<code>logger</code>","text":"<p>Created on 2025-01-25</p> <p>@author: wf</p>"},{"location":"#mbusread.logger.Logger","title":"<code>Logger</code>","text":"<p>Logger singleton for M-Bus reader</p> Source code in <code>mbusread/logger.py</code> <pre><code>class Logger:\n    \"\"\"Logger singleton for M-Bus reader\"\"\"\n    _logger = None\n\n    @classmethod\n    def setup_logger(cls, debug: bool = False) -&gt; logging.Logger:\n        if cls._logger is None:\n            cls._logger = logging.getLogger(\"MBusReader\")\n            if debug:\n                cls._logger.setLevel(logging.DEBUG)\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter(\n                \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n            )\n            handler.setFormatter(formatter)\n            cls._logger.addHandler(handler)\n        return cls._logger\n</code></pre>"},{"location":"#mbusread.mbus_config","title":"<code>mbus_config</code>","text":"<p>Created on 2025-01-22 M-Bus configuration Classes to be read from configuration files e.g. YAML encoded @author: wf</p>"},{"location":"#mbusread.mbus_config.Device","title":"<code>Device</code>","text":"<p>A device class for M-Bus devices storing manufacturer reference</p> <p>Note on wakeup timing: The M-Bus standard formula suggests 33 bytes per 300 baud with start+8data+stop = 10 bits. However, we use configured pattern repetitions: - Default is 528 times (0x55) - Ultramaxx needs 1056 times (66 lines * 16 bytes) The total time includes sending these patterns at the given baudrate plus a fixed delay time.</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass Device:\n    \"\"\"\n    A device class for M-Bus devices storing manufacturer reference\n\n    Note on wakeup timing:\n    The M-Bus standard formula suggests 33 bytes per 300 baud with\n    start+8data+stop = 10 bits. However, we use configured pattern repetitions:\n    - Default is 528 times (0x55)\n    - Ultramaxx needs 1056 times (66 lines * 16 bytes)\n    The total time includes sending these patterns at the given baudrate\n    plus a fixed delay time.\n    \"\"\"\n\n    model: str\n    title: str = \"\"\n    url: str = \"\"\n    doc_url: str = \"\"\n    has_echo: bool = False\n    wakeup_pattern: str = \"55\"\n    wakeup_times: int = 528  # Number of pattern repetitions\n    wakeup_delay: float = 0.35  # secs\n    messages: Dict[str, MBusMessage] = field(default_factory=dict)\n\n    def wakeup_time(self, baudrate: int = 2400) -&gt; float:\n        \"\"\"Calculate total wakeup time based on pattern repetitions\"\"\"\n        secs = (self.wakeup_times * len(bytes.fromhex(self.wakeup_pattern))) / (\n            baudrate / 10\n        ) + self.wakeup_delay\n        return secs\n\n    def as_html(self) -&gt; str:\n        \"\"\"Generate HTML representation of the device including wakeup info\"\"\"\n        title = self.title if self.title else self.model\n        device_link = (\n            Link.create(url=self.url, text=title, target=\"_blank\")\n            if self.doc_url\n            else title\n        )\n        doc_link = (\n            Link.create(url=self.doc_url, text=\"\ud83d\udcc4\", target=\"_blank\")\n            if self.doc_url\n            else \"\"\n        )\n        mfr_html = (\n            self.manufacturer.as_html() if hasattr(self, \"manufacturer\") else self.mid\n        )\n        wakeup_html = f\"\"\"wakeup: {self.wakeup_pattern} = {self.wakeup_times}\u00d70x{self.wakeup_pattern} ({self.wakeup_time(2400):.2f}s incl. {self.wakeup_delay}s delay)\"\"\"\n        markup = f\"\"\"{mfr_html} \u2192 {device_link}{doc_link}&lt;br&gt;\n{wakeup_html}\"\"\"\n        return markup\n</code></pre>"},{"location":"#mbusread.mbus_config.Device.as_html","title":"<code>as_html()</code>","text":"<p>Generate HTML representation of the device including wakeup info</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>    def as_html(self) -&gt; str:\n        \"\"\"Generate HTML representation of the device including wakeup info\"\"\"\n        title = self.title if self.title else self.model\n        device_link = (\n            Link.create(url=self.url, text=title, target=\"_blank\")\n            if self.doc_url\n            else title\n        )\n        doc_link = (\n            Link.create(url=self.doc_url, text=\"\ud83d\udcc4\", target=\"_blank\")\n            if self.doc_url\n            else \"\"\n        )\n        mfr_html = (\n            self.manufacturer.as_html() if hasattr(self, \"manufacturer\") else self.mid\n        )\n        wakeup_html = f\"\"\"wakeup: {self.wakeup_pattern} = {self.wakeup_times}\u00d70x{self.wakeup_pattern} ({self.wakeup_time(2400):.2f}s incl. {self.wakeup_delay}s delay)\"\"\"\n        markup = f\"\"\"{mfr_html} \u2192 {device_link}{doc_link}&lt;br&gt;\n{wakeup_html}\"\"\"\n        return markup\n</code></pre>"},{"location":"#mbusread.mbus_config.Device.wakeup_time","title":"<code>wakeup_time(baudrate=2400)</code>","text":"<p>Calculate total wakeup time based on pattern repetitions</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>def wakeup_time(self, baudrate: int = 2400) -&gt; float:\n    \"\"\"Calculate total wakeup time based on pattern repetitions\"\"\"\n    secs = (self.wakeup_times * len(bytes.fromhex(self.wakeup_pattern))) / (\n        baudrate / 10\n    ) + self.wakeup_delay\n    return secs\n</code></pre>"},{"location":"#mbusread.mbus_config.Link","title":"<code>Link</code>","text":"<p>a link</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>class Link:\n    \"\"\"\n    a link\n    \"\"\"\n\n    red = \"color: red;text-decoration: underline;\"\n    blue = \"color: blue;text-decoration: underline;\"\n\n    @staticmethod\n    def create(\n        url, text, tooltip=None, target=None, style: str = None, url_encode=False\n    ):\n        \"\"\"\n        Create a link for the given URL and text, with optional URL encoding.\n\n        Args:\n            url (str): The URL.\n            text (str): The link text.\n            tooltip (str): An optional tooltip.\n            target (str): Target attribute, e.g., _blank for opening the link in a new tab.\n            style (str): CSS style to be applied.\n            url_encode (bool): Flag to indicate if the URL needs encoding. default: False\n\n        Returns:\n            str: HTML anchor tag as a string.\n        \"\"\"\n        if url_encode:\n            url = quote(url)\n\n        title = \"\" if tooltip is None else f\" title='{tooltip}'\"\n        target = \"\" if target is None else f\" target='{target}'\"\n        if style is None:\n            style = Link.blue\n        style = f\" style='{style}'\"\n        link = f\"&lt;a href='{url}'{title}{target}{style}&gt;{text}&lt;/a&gt;\"\n        return link\n</code></pre>"},{"location":"#mbusread.mbus_config.Link.create","title":"<code>create(url, text, tooltip=None, target=None, style=None, url_encode=False)</code>  <code>staticmethod</code>","text":"<p>Create a link for the given URL and text, with optional URL encoding.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL.</p> required <code>text</code> <code>str</code> <p>The link text.</p> required <code>tooltip</code> <code>str</code> <p>An optional tooltip.</p> <code>None</code> <code>target</code> <code>str</code> <p>Target attribute, e.g., _blank for opening the link in a new tab.</p> <code>None</code> <code>style</code> <code>str</code> <p>CSS style to be applied.</p> <code>None</code> <code>url_encode</code> <code>bool</code> <p>Flag to indicate if the URL needs encoding. default: False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>HTML anchor tag as a string.</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@staticmethod\ndef create(\n    url, text, tooltip=None, target=None, style: str = None, url_encode=False\n):\n    \"\"\"\n    Create a link for the given URL and text, with optional URL encoding.\n\n    Args:\n        url (str): The URL.\n        text (str): The link text.\n        tooltip (str): An optional tooltip.\n        target (str): Target attribute, e.g., _blank for opening the link in a new tab.\n        style (str): CSS style to be applied.\n        url_encode (bool): Flag to indicate if the URL needs encoding. default: False\n\n    Returns:\n        str: HTML anchor tag as a string.\n    \"\"\"\n    if url_encode:\n        url = quote(url)\n\n    title = \"\" if tooltip is None else f\" title='{tooltip}'\"\n    target = \"\" if target is None else f\" target='{target}'\"\n    if style is None:\n        style = Link.blue\n    style = f\" style='{style}'\"\n    link = f\"&lt;a href='{url}'{title}{target}{style}&gt;{text}&lt;/a&gt;\"\n    return link\n</code></pre>"},{"location":"#mbusread.mbus_config.MBusConfig","title":"<code>MBusConfig</code>","text":"<p>Manages M-Bus manufacture/devices/message hierarchy</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass MBusConfig:\n    \"\"\"\n    Manages M-Bus manufacture/devices/message hierarchy\n    \"\"\"\n\n    manufacturers: Dict[str, Manufacturer] = field(default_factory=dict)\n\n    @classmethod\n    def get(cls, yaml_path: str = None) -&gt; \"MBusConfig\":\n        if yaml_path is None:\n            yaml_path = cls.examples_path() + \"/mbus_config.yaml\"\n\n        # Load raw YAML data\n        mbus_config = cls.load_from_yaml_file(yaml_path)\n        mbus_config.relink()\n        return mbus_config\n\n    def relink(self):\n        \"\"\"\n        Link objects in the manufacturer/device/message hierarchy\n        \"\"\"\n        for manufacturer in self.manufacturers.values():\n            for _device_id, device in manufacturer.devices.items():\n                device.manufacturer = manufacturer\n                for _message_id, message in device.messages.items():\n                    message.device = device\n\n    @classmethod\n    def examples_path(cls) -&gt; str:\n        # the root directory (default: examples)\n        path = os.path.join(os.path.dirname(__file__), \"../mbusread_examples\")\n        path = os.path.abspath(path)\n        return path\n</code></pre>"},{"location":"#mbusread.mbus_config.MBusConfig.relink","title":"<code>relink()</code>","text":"<p>Link objects in the manufacturer/device/message hierarchy</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>def relink(self):\n    \"\"\"\n    Link objects in the manufacturer/device/message hierarchy\n    \"\"\"\n    for manufacturer in self.manufacturers.values():\n        for _device_id, device in manufacturer.devices.items():\n            device.manufacturer = manufacturer\n            for _message_id, message in device.messages.items():\n                message.device = device\n</code></pre>"},{"location":"#mbusread.mbus_config.MBusIoConfig","title":"<code>MBusIoConfig</code>","text":"<p>Configuration data class for M-Bus reader</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass MBusIoConfig:\n    \"\"\"Configuration data class for M-Bus reader\"\"\"\n\n    serial_device: str = \"/dev/ttyUSB0\"\n    initial_baudrate: int = 2400\n    timeout: float = 10.0\n</code></pre>"},{"location":"#mbusread.mbus_config.MBusMessage","title":"<code>MBusMessage</code>","text":"<p>An M-Bus message</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass MBusMessage:\n    \"\"\"\n    An M-Bus message\n    \"\"\"\n\n    name: str\n    title: str\n    hex: str\n    valid: bool = False\n\n    def as_html(self) -&gt; str:\n        device_html = self.device.as_html() if hasattr(self, \"device\") else self.did\n        example_text = f\"{self.name}: {self.title}\" if self.title else self.name\n        return f\"{device_html} \u2192 {example_text}\"\n</code></pre>"},{"location":"#mbusread.mbus_config.Manufacturer","title":"<code>Manufacturer</code>","text":"<p>A manufacturer of M-Bus devices</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass Manufacturer:\n    \"\"\"\n    A manufacturer of M-Bus devices\n    \"\"\"\n\n    name: str\n    url: str\n    country: str = \"Germany\"  # Most M-Bus manufacturers are German\n    devices: Dict[str, Device] = field(default_factory=dict)\n\n    def as_html(self) -&gt; str:\n        return (\n            Link.create(url=self.url, text=self.name, target=\"_blank\")\n            if self.url\n            else self.name\n        )\n</code></pre>"},{"location":"#mbusread.mbus_config.MqttConfig","title":"<code>MqttConfig</code>","text":"<p>MQTT configuration</p> Source code in <code>mbusread/mbus_config.py</code> <pre><code>@lod_storable\nclass MqttConfig:\n    \"\"\"MQTT configuration\"\"\"\n\n    broker: str = \"localhost\"\n    port: int = 1883\n    username: str = None\n    password: str = None\n    topic: str = \"mbus/data\"\n</code></pre>"},{"location":"#mbusread.mbus_mqtt","title":"<code>mbus_mqtt</code>","text":"<p>Created on 2025-01-24 based on https://github.com/ganehag/pyMeterBus/discussions/40</p> <p>@author: Thorsten1982,wf</p>"},{"location":"#mbusread.mbus_mqtt.MBusMqtt","title":"<code>MBusMqtt</code>","text":"<p>MQTT handler for M-Bus data</p> Source code in <code>mbusread/mbus_mqtt.py</code> <pre><code>class MBusMqtt:\n    \"\"\"MQTT handler for M-Bus data\"\"\"\n\n    def __init__(self, config: MqttConfig):\n        self.config = config\n        self.logger = logging.getLogger(\"MBusMqtt\")\n\n    @classmethod\n    def from_yaml(cls, yaml_path: str) -&gt; \"MBusMqtt\":\n        config = cls.load_from_yaml_file(yaml_path)\n        mqtt\n        return mqtt\n\n    def publish(self, record:Dict):\n        \"\"\"Publish M-Bus data via MQTT\"\"\"\n        client = mqtt.Client()\n        if self.config.username:\n            client.username_pw_set(self.config.username, self.config.password)\n\n        try:\n            client.connect(self.config.broker, self.config.port, 60)\n            client.loop_start()\n            json_str = json.dumps(record, indent=2)\n            client.publish(self.config.topic, json_str)\n            time.sleep(1)\n            client.loop_stop()\n            client.disconnect()\n        except Exception as e:\n            self.logger.error(f\"MQTT error: {str(e)}\")\n</code></pre>"},{"location":"#mbusread.mbus_mqtt.MBusMqtt.publish","title":"<code>publish(record)</code>","text":"<p>Publish M-Bus data via MQTT</p> Source code in <code>mbusread/mbus_mqtt.py</code> <pre><code>def publish(self, record:Dict):\n    \"\"\"Publish M-Bus data via MQTT\"\"\"\n    client = mqtt.Client()\n    if self.config.username:\n        client.username_pw_set(self.config.username, self.config.password)\n\n    try:\n        client.connect(self.config.broker, self.config.port, 60)\n        client.loop_start()\n        json_str = json.dumps(record, indent=2)\n        client.publish(self.config.topic, json_str)\n        time.sleep(1)\n        client.loop_stop()\n        client.disconnect()\n    except Exception as e:\n        self.logger.error(f\"MQTT error: {str(e)}\")\n</code></pre>"},{"location":"#mbusread.mbus_parser","title":"<code>mbus_parser</code>","text":"<p>Created on 2025-01-22 see also https://github.com/ganehag/pyMeterBus/discussions/40 @author: Thorsten1982, wf</p>"},{"location":"#mbusread.mbus_parser.MBusParser","title":"<code>MBusParser</code>","text":"<p>parse MBus data</p> Source code in <code>mbusread/mbus_parser.py</code> <pre><code>class MBusParser:\n    \"\"\"\n    parse MBus data\n    \"\"\"\n\n    def __init__(self, debug: bool = False):\n        self.debug = debug\n        self.logger = Logger.setup_logger(debug=debug)\n\n    def fromhex(self, x, base=16):\n        \"\"\"Convert hex string to integer\"\"\"\n        return int(x, base)\n\n    def get_frame_json(self, frame):\n        \"\"\"\n        Workarounds for JSON bugs in pyMeterBus\n        \"\"\"\n        if isinstance(frame, TelegramShort):\n            # Handle serialization explicitly for TelegramShort\n            interpreted_data = frame.interpreted\n            json_str = json.dumps(\n                interpreted_data, sort_keys=True, indent=2, default=str\n            )\n        elif hasattr(frame, \"to_JSON\"):\n            json_str = frame.to_JSON()\n        else:\n            # Fallback to basic frame info\n            data = {\n                \"header\": {\n                    \"start\": frame.header.startField.parts[0],\n                    \"length\": len(frame.body.bodyHeader.ci_field.parts) + 2,\n                    \"control\": frame.header.cField.parts[0],\n                    \"address\": frame.header.aField.parts[0],\n                },\n                \"body\": {\"ci_field\": frame.body.bodyHeader.ci_field.parts[0]},\n            }\n            json_str = json.dumps(data)\n        return json_str\n\n    def parse_mbus_frame(self, hex_data):\n        \"\"\"\n        Parse M-Bus hex data and return mbus frame\n        Returns tuple of (error_msg, mbus_frame)\n        \"\"\"\n        frame = None\n        error_msg = None\n        try:\n            filtered_data = \"\".join(char for char in hex_data if char.isalnum())\n            data = list(map(self.fromhex, re.findall(\"..\", filtered_data)))\n            frame = meterbus.load(data)\n        except Exception as ex:\n            error_type = type(ex).__name__\n            error_msg = f\"Error parsing M-Bus data: {error_type}: {str(ex)}\"\n            if self.debug:\n                traceback.format_exception(ex)\n        return error_msg, frame\n\n    def extract_frame(self, data: bytes) -&gt; Optional[bytes]:\n        \"\"\"Extract valid M-Bus frame between start (0x68) and end (0x16) bytes\"\"\"\n        start_byte = b\"\\x68\"\n        end_byte = b\"\\x16\"\n        result = None\n        status = \"\u274c\"\n\n        if data:\n            try:\n                start_idx = data.index(start_byte)\n                end_idx = data.find(end_byte, start_idx + 1)\n                if end_idx != -1:\n                    result = data[start_idx : end_idx + 1]\n                    status = \"\u2705\"\n                else:\n                    status = \"\u26a0\ufe0f\"\n            except ValueError:\n                pass\n\n        self.logger.debug(\n            f\"Frame extraction {status}: {result.hex() if result else 'None'}\"\n        )\n        return result\n</code></pre>"},{"location":"#mbusread.mbus_parser.MBusParser.extract_frame","title":"<code>extract_frame(data)</code>","text":"<p>Extract valid M-Bus frame between start (0x68) and end (0x16) bytes</p> Source code in <code>mbusread/mbus_parser.py</code> <pre><code>def extract_frame(self, data: bytes) -&gt; Optional[bytes]:\n    \"\"\"Extract valid M-Bus frame between start (0x68) and end (0x16) bytes\"\"\"\n    start_byte = b\"\\x68\"\n    end_byte = b\"\\x16\"\n    result = None\n    status = \"\u274c\"\n\n    if data:\n        try:\n            start_idx = data.index(start_byte)\n            end_idx = data.find(end_byte, start_idx + 1)\n            if end_idx != -1:\n                result = data[start_idx : end_idx + 1]\n                status = \"\u2705\"\n            else:\n                status = \"\u26a0\ufe0f\"\n        except ValueError:\n            pass\n\n    self.logger.debug(\n        f\"Frame extraction {status}: {result.hex() if result else 'None'}\"\n    )\n    return result\n</code></pre>"},{"location":"#mbusread.mbus_parser.MBusParser.fromhex","title":"<code>fromhex(x, base=16)</code>","text":"<p>Convert hex string to integer</p> Source code in <code>mbusread/mbus_parser.py</code> <pre><code>def fromhex(self, x, base=16):\n    \"\"\"Convert hex string to integer\"\"\"\n    return int(x, base)\n</code></pre>"},{"location":"#mbusread.mbus_parser.MBusParser.get_frame_json","title":"<code>get_frame_json(frame)</code>","text":"<p>Workarounds for JSON bugs in pyMeterBus</p> Source code in <code>mbusread/mbus_parser.py</code> <pre><code>def get_frame_json(self, frame):\n    \"\"\"\n    Workarounds for JSON bugs in pyMeterBus\n    \"\"\"\n    if isinstance(frame, TelegramShort):\n        # Handle serialization explicitly for TelegramShort\n        interpreted_data = frame.interpreted\n        json_str = json.dumps(\n            interpreted_data, sort_keys=True, indent=2, default=str\n        )\n    elif hasattr(frame, \"to_JSON\"):\n        json_str = frame.to_JSON()\n    else:\n        # Fallback to basic frame info\n        data = {\n            \"header\": {\n                \"start\": frame.header.startField.parts[0],\n                \"length\": len(frame.body.bodyHeader.ci_field.parts) + 2,\n                \"control\": frame.header.cField.parts[0],\n                \"address\": frame.header.aField.parts[0],\n            },\n            \"body\": {\"ci_field\": frame.body.bodyHeader.ci_field.parts[0]},\n        }\n        json_str = json.dumps(data)\n    return json_str\n</code></pre>"},{"location":"#mbusread.mbus_parser.MBusParser.parse_mbus_frame","title":"<code>parse_mbus_frame(hex_data)</code>","text":"<p>Parse M-Bus hex data and return mbus frame Returns tuple of (error_msg, mbus_frame)</p> Source code in <code>mbusread/mbus_parser.py</code> <pre><code>def parse_mbus_frame(self, hex_data):\n    \"\"\"\n    Parse M-Bus hex data and return mbus frame\n    Returns tuple of (error_msg, mbus_frame)\n    \"\"\"\n    frame = None\n    error_msg = None\n    try:\n        filtered_data = \"\".join(char for char in hex_data if char.isalnum())\n        data = list(map(self.fromhex, re.findall(\"..\", filtered_data)))\n        frame = meterbus.load(data)\n    except Exception as ex:\n        error_type = type(ex).__name__\n        error_msg = f\"Error parsing M-Bus data: {error_type}: {str(ex)}\"\n        if self.debug:\n            traceback.format_exception(ex)\n    return error_msg, frame\n</code></pre>"},{"location":"#mbusread.mbus_reader","title":"<code>mbus_reader</code>","text":"<p>Created on 2025-01-24 based on https://github.com/ganehag/pyMeterBus/discussions/40</p> <p>@author: Thorsten1982,wf</p>"},{"location":"#mbusread.mbus_reader.MBusReader","title":"<code>MBusReader</code>","text":"<p>Reader for Meter Bus data</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>class MBusReader:\n    \"\"\"Reader for Meter Bus data\"\"\"\n\n    def __init__(\n        self,\n        device: Device,\n        io_config: Optional[MBusIoConfig] = None,\n        i18n: I18n = None,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Initialize MBusReader with configuration\n        \"\"\"\n        self.debug = debug\n        self.device = device\n        self.logger = Logger.setup_logger(debug=debug)\n        self.io_config = io_config or MBusIoConfig\n        if i18n is None:\n            i18n = I18n.default()\n        self.i18n = i18n\n        self.ser = self._setup_serial()\n\n    def _setup_serial(self) -&gt; serial.Serial:\n        \"\"\"Initialize serial connection\"\"\"\n        ser = serial.Serial(\n            port=self.io_config.serial_device,\n            baudrate=self.io_config.initial_baudrate,\n            bytesize=8,\n            parity=serial.PARITY_NONE,\n            stopbits=1,\n            timeout=self.io_config.timeout,\n        )\n        return ser\n\n    def show_echo(self, msg: str, echo: str, echo_display_len: int = 32):\n        if echo != msg:\n            # Truncate to first echo_display_len bytes for readability\n            sent_hex = msg[:echo_display_len].hex()\n            echo_hex = echo[:echo_display_len].hex()\n            warn_msg = f\"\"\"Echo mismatch!  Sent {len(msg)} Repl {len(echo)}\nSent={sent_hex}\nRepl={echo_hex}\"\"\"\n            self.logger.warning(warn_msg)\n        else:\n            self.logger.debug(f\"Echo matched: {len(echo)} bytes\")\n\n    def ser_write(self, msg: bytes, info: str, echo_display_len: int = 16) -&gt; None:\n        \"\"\"\n        Writes a message to the serial port and validates the echo.\n\n        Args:\n            msg (bytes): The message to write as a byte string.\n            info (str): The log message key for identifying the operation.\n\n        Logs:\n            A warning if the echo does not match the sent message.\n            A debug message if the echo matches.\n        \"\"\"\n        self.logger.info(self.i18n.get(info))\n        self.ser.write(msg)\n        self.ser.flush()\n        if self.device.has_echo:\n            # Check and validate echo\n            echo = self.ser.read(len(msg))\n            self.show_echo(msg, echo, echo_display_len)\n\n    def wake_up(self, device: Device) -&gt; None:\n        \"\"\"Perform the wakeup sequence based on device configuration\"\"\"\n        try:\n            pattern = bytes.fromhex(device.wakeup_pattern)\n            times = device.wakeup_times\n            sleep_time = device.wakeup_delay\n\n            self.ser_write(pattern * times, \"wake_up_started\")\n            time.sleep(sleep_time)\n            self.ser.parity = serial.PARITY_EVEN\n            self.logger.info(self.i18n.get(\"wake_up_complete\"))\n        except serial.SerialException as e:\n            self.logger.error(self.i18n.get(\"serial_error\", \"wake_up\", str(e)))\n\n    def get_data(self, read_data_msg_key: str = \"read_data\") -&gt; Optional[bytes]:\n        \"\"\"Get data from the M-Bus device\"\"\"\n        try:\n            if read_data_msg_key not in self.device.messages:\n                raise ValueError(f\"Message {read_data_msg_key} not found\")\n\n            self.wake_up(self.device)\n            read_data = bytes.fromhex(self.device.messages[read_data_msg_key].hex)\n            self.ser_write(read_data, \"reading_data\")\n\n            result = self.ser.read(620)\n            if not result:\n                self.logger.warning(self.i18n.get(\"no_data_received\"))\n                return None\n\n            byte_array_hex = binascii.hexlify(result)\n            self.logger.info(self.i18n.get(\"read_data_hex\", byte_array_hex.decode()))\n            return result\n\n        except serial.SerialException as e:\n            self.logger.error(self.i18n.get(\"serial_error\", \"get_data\", str(e)))\n            return None\n\n    def send_mbus_request(self, msg_id: str) -&gt; None:\n        \"\"\"Send an M-Bus request to the device\"\"\"\n        try:\n            if msg_id not in self.device.messages:\n                raise ValueError(f\"Message {msg_id} not found in device configuration\")\n\n            request = bytes.fromhex(self.device.messages[msg_id].hex)\n            self.logger.info(self.i18n.get(\"sending_request\"))\n            self.ser.write(request)\n        except serial.SerialException as e:\n            self.logger.error(\n                self.i18n.get(\"serial_error\", \"send_mbus_request\", str(e))\n            )\n\n    def read_response(self, buffer_size: int = 256) -&gt; Optional[bytes]:\n        \"\"\"Read the response from the device\"\"\"\n        try:\n            response = self.ser.read(buffer_size)\n            if response:\n                hex_response = \" \".join(format(b, \"02x\") for b in response)\n                self.logger.info(self.i18n.get(\"response_received\", hex_response))\n                return response\n            return None\n        except serial.SerialException as e:\n            self.logger.error(self.i18n.get(\"serial_error\", \"read_response\", str(e)))\n            return None\n\n    def close(self) -&gt; None:\n        \"\"\"Close the serial connection\"\"\"\n        if self.ser and self.ser.is_open:\n            self.ser.close()\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.__init__","title":"<code>__init__(device, io_config=None, i18n=None, debug=False)</code>","text":"<p>Initialize MBusReader with configuration</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def __init__(\n    self,\n    device: Device,\n    io_config: Optional[MBusIoConfig] = None,\n    i18n: I18n = None,\n    debug: bool = False,\n):\n    \"\"\"\n    Initialize MBusReader with configuration\n    \"\"\"\n    self.debug = debug\n    self.device = device\n    self.logger = Logger.setup_logger(debug=debug)\n    self.io_config = io_config or MBusIoConfig\n    if i18n is None:\n        i18n = I18n.default()\n    self.i18n = i18n\n    self.ser = self._setup_serial()\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.close","title":"<code>close()</code>","text":"<p>Close the serial connection</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the serial connection\"\"\"\n    if self.ser and self.ser.is_open:\n        self.ser.close()\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.get_data","title":"<code>get_data(read_data_msg_key='read_data')</code>","text":"<p>Get data from the M-Bus device</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def get_data(self, read_data_msg_key: str = \"read_data\") -&gt; Optional[bytes]:\n    \"\"\"Get data from the M-Bus device\"\"\"\n    try:\n        if read_data_msg_key not in self.device.messages:\n            raise ValueError(f\"Message {read_data_msg_key} not found\")\n\n        self.wake_up(self.device)\n        read_data = bytes.fromhex(self.device.messages[read_data_msg_key].hex)\n        self.ser_write(read_data, \"reading_data\")\n\n        result = self.ser.read(620)\n        if not result:\n            self.logger.warning(self.i18n.get(\"no_data_received\"))\n            return None\n\n        byte_array_hex = binascii.hexlify(result)\n        self.logger.info(self.i18n.get(\"read_data_hex\", byte_array_hex.decode()))\n        return result\n\n    except serial.SerialException as e:\n        self.logger.error(self.i18n.get(\"serial_error\", \"get_data\", str(e)))\n        return None\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.read_response","title":"<code>read_response(buffer_size=256)</code>","text":"<p>Read the response from the device</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def read_response(self, buffer_size: int = 256) -&gt; Optional[bytes]:\n    \"\"\"Read the response from the device\"\"\"\n    try:\n        response = self.ser.read(buffer_size)\n        if response:\n            hex_response = \" \".join(format(b, \"02x\") for b in response)\n            self.logger.info(self.i18n.get(\"response_received\", hex_response))\n            return response\n        return None\n    except serial.SerialException as e:\n        self.logger.error(self.i18n.get(\"serial_error\", \"read_response\", str(e)))\n        return None\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.send_mbus_request","title":"<code>send_mbus_request(msg_id)</code>","text":"<p>Send an M-Bus request to the device</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def send_mbus_request(self, msg_id: str) -&gt; None:\n    \"\"\"Send an M-Bus request to the device\"\"\"\n    try:\n        if msg_id not in self.device.messages:\n            raise ValueError(f\"Message {msg_id} not found in device configuration\")\n\n        request = bytes.fromhex(self.device.messages[msg_id].hex)\n        self.logger.info(self.i18n.get(\"sending_request\"))\n        self.ser.write(request)\n    except serial.SerialException as e:\n        self.logger.error(\n            self.i18n.get(\"serial_error\", \"send_mbus_request\", str(e))\n        )\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.ser_write","title":"<code>ser_write(msg, info, echo_display_len=16)</code>","text":"<p>Writes a message to the serial port and validates the echo.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>bytes</code> <p>The message to write as a byte string.</p> required <code>info</code> <code>str</code> <p>The log message key for identifying the operation.</p> required Logs <p>A warning if the echo does not match the sent message. A debug message if the echo matches.</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def ser_write(self, msg: bytes, info: str, echo_display_len: int = 16) -&gt; None:\n    \"\"\"\n    Writes a message to the serial port and validates the echo.\n\n    Args:\n        msg (bytes): The message to write as a byte string.\n        info (str): The log message key for identifying the operation.\n\n    Logs:\n        A warning if the echo does not match the sent message.\n        A debug message if the echo matches.\n    \"\"\"\n    self.logger.info(self.i18n.get(info))\n    self.ser.write(msg)\n    self.ser.flush()\n    if self.device.has_echo:\n        # Check and validate echo\n        echo = self.ser.read(len(msg))\n        self.show_echo(msg, echo, echo_display_len)\n</code></pre>"},{"location":"#mbusread.mbus_reader.MBusReader.wake_up","title":"<code>wake_up(device)</code>","text":"<p>Perform the wakeup sequence based on device configuration</p> Source code in <code>mbusread/mbus_reader.py</code> <pre><code>def wake_up(self, device: Device) -&gt; None:\n    \"\"\"Perform the wakeup sequence based on device configuration\"\"\"\n    try:\n        pattern = bytes.fromhex(device.wakeup_pattern)\n        times = device.wakeup_times\n        sleep_time = device.wakeup_delay\n\n        self.ser_write(pattern * times, \"wake_up_started\")\n        time.sleep(sleep_time)\n        self.ser.parity = serial.PARITY_EVEN\n        self.logger.info(self.i18n.get(\"wake_up_complete\"))\n    except serial.SerialException as e:\n        self.logger.error(self.i18n.get(\"serial_error\", \"wake_up\", str(e)))\n</code></pre>"},{"location":"#mbusread.mbus_reader_cmd","title":"<code>mbus_reader_cmd</code>","text":""},{"location":"#mbusread.mbus_reader_cmd.MBusCommunicator","title":"<code>MBusCommunicator</code>","text":"<p>communicate with an M-Bus device</p> Source code in <code>mbusread/mbus_reader_cmd.py</code> <pre><code>class MBusCommunicator:\n    \"\"\"\n    communicate with an M-Bus device\n    \"\"\"\n\n    def __init__(self, args: argparse.Namespace):\n        self.args=args\n        self.logger = Logger.setup_logger(args.debug)\n        i18n = I18n.default()\n        i18n.language = args.lang\n        mbus_config = MBusConfig.get(args.config)\n        io_config = MBusIoConfig.load_from_yaml_file(args.io_config)\n        device = mbus_config.manufacturers[args.manufacturer].devices[args.device]\n        self.mqtt_config = (\n            MqttConfig.load_from_yaml_file(args.mqtt_config)\n            if args.mqtt_config\n            else None\n        )\n\n        self.reader = MBusReader(\n            device=device, io_config=io_config, i18n=i18n, debug=args.debug\n        )\n        self.parser = MBusParser(debug=args.debug)\n\n        pass\n\n    @classmethod\n    def get_parser(cls) -&gt; argparse.ArgumentParser:\n        parser = argparse.ArgumentParser(description=\"M-Bus Reader\")\n        parser.add_argument(\n            \"-c\",\n            \"--config\",\n            default=MBusConfig.examples_path() + \"/mbus_config.yaml\",\n            help=\"Config file path [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-i\",\n            \"--io_config\",\n            default=MBusConfig.examples_path() + \"/mbus_io_config.yaml\",\n            help=\"IO config file path [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-q\",\n            \"--mqtt_config\",\n            default=MBusConfig.examples_path() + \"/mqtt_config.yaml\",\n            help=\"MQTT config file path [default: %(default)s]\",\n        )\n\n        parser.add_argument(\n            \"-D\",\n            \"--device\",\n            default=\"cf_echo_ii\",\n            help=\"Device type [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-m\", \"--message\", help=\"Message ID to send [default: %(default)s]\"\n        )\n        parser.add_argument(\n            \"-M\",\n            \"--manufacturer\",\n            default=\"allmess\",\n            help=\"Manufacturer ID [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"--mqtt\", action=\"store_true\", help=\"Enable MQTT publishing\"\n        )\n        parser.add_argument(\n            \"--lang\",\n            choices=[\"en\", \"de\"],\n            default=\"en\",\n            help=\"Language for messages (default: en)\",\n        )\n        parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug logging\")\n        return parser\n\n    def work(self):\n        try:\n            if self.args.message:\n                self.reader.send_mbus_request(self.args.message)\n                raw_data = self.reader.read_response()\n            else:\n                raw_data = self.reader.get_data()\n            frame = self.parser.extract_frame(raw_data)\n            if not frame:\n                self.logger.warning(\"No valid frame found in data\")\n                return None\n\n            error_msg, mbus_frame = self.parser.parse_mbus_frame(frame.hex())\n            if error_msg:\n                self.logger.error(f\"Frame parsing error: {error_msg}\")\n                return None\n\n            json_str = self.parser.get_frame_json(mbus_frame)\n            record = json.loads(json_str)\n            pretty_json=json.dumps(record, indent=2, default=str)\n            if self.args.debug:\n                print(pretty_json)\n\n            if self.args.mqtt and self.mqtt_config:\n                mqtt_handler = MBusMqtt(self.mqtt_config)\n                mqtt_handler.publish(record)\n        finally:\n            self.reader.close()\n</code></pre>"},{"location":"#mbusread.mbus_viewer","title":"<code>mbus_viewer</code>","text":""},{"location":"#mbusread.mbus_viewer.MBusViewer","title":"<code>MBusViewer</code>","text":"<p>               Bases: <code>MBusParser</code></p> <p>Enhanced M-Bus message viewer with improved error handling and UI organization</p> Source code in <code>mbusread/mbus_viewer.py</code> <pre><code>class MBusViewer(MBusParser):\n    \"\"\"Enhanced M-Bus message viewer with improved error handling and UI organization\"\"\"\n\n    def __init__(self, solution=None):\n        super().__init__()\n        self.solution = solution\n        self.config = MBusConfig.get()\n\n        # Initialize UI components\n        self.hex_input: Optional[ui.textarea] = None\n        self.json_view: Optional[ui.code] = None\n        self.details_view: Optional[ui.html] = None\n        self.error_view: Optional[ui.html] = None\n\n    def create_textarea(\n        self, label: str, placeholder: Optional[str] = None, height: str = \"h-32\"\n    ) -&gt; ui.textarea:\n        \"\"\"Create a consistent textarea with error handling\"\"\"\n        return (\n            ui.textarea(label=label, placeholder=placeholder)\n            .classes(f\"w-full {height}\")\n            .props(\"clearable outlined\")\n        )\n\n    def setup_ui(self) -&gt; None:\n        \"\"\"Create the main UI layout with two-column design\"\"\"\n        try:\n            ui.label(\"M-Bus Message Parser\").classes(\"text-2xl font-bold mb-4\")\n\n            with ui.row().classes(\"w-full gap-4\"):\n                # Left column\n                with ui.column().classes(\"flex-1\"):\n                    with ui.card().classes(\"w-full\"):\n                        with ui.row().classes(\"gap-8\"):\n                            self.manufacturer_select = RadioSelection[Manufacturer](\n                                \"Manufacturer\",\n                                \"name\",\n                                selection=self.config.manufacturers,\n                            ).setup(self._on_manufacturer_change)\n\n                            self.device_select = RadioSelection[Device](\n                                \"Device\",\n                                \"model\",\n                                selection=self.manufacturer_select.item.devices,\n                            ).setup(self._on_device_change)\n\n                        # Device details\n                        with ui.card().classes(\"w-full\"):\n                            ui.label(\"Device Details\").classes(\"text-lg font-bold mb-2\")\n                            self.details_view = ui.html()\n\n                        with ui.row().classes(\"mt-4\"):\n                            self.message_select = RadioSelection[MBusMessage](\n                                \"Message\",\n                                \"name\",\n                                selection=self.device_select.item.messages,\n                            ).setup(self._on_message_change)\n\n                    # Input area\n                    with ui.card().classes(\"w-full mt-4\"):\n                        self.hex_input = self.create_textarea(\n                            \"Enter M-Bus hex message\",\n                            \"e.g. 68 4d 4d 68 08 00 72 26 54 83 22 77...\",\n                        )\n                        ui.button(\n                            \"Parse Message\", on_click=self._parse_message\n                        ).classes(\"mt-4\")\n\n                # Right column\n                with ui.column().classes(\"flex-1\"):\n                    # Results area\n                    with ui.row().classes(\"w-full\"):\n                        self.error_view = ui.html().classes(\"text-red-500\")\n                        self.json_view = ui.code(\"\", language=\"json\").classes(\n                            \"w-full h-96\"\n                        )\n\n        except Exception as ex:\n            self._handle_error(\"Error setting up UI\", ex)\n\n    def _on_manufacturer_change(self, manufacturer: Manufacturer) -&gt; None:\n        \"\"\"Update device options when manufacturer changes\"\"\"\n        try:\n            self.device_select.selection = manufacturer.devices\n            self.device_select._update_options()\n        except Exception as ex:\n            self._handle_error(\"Error updating devices\", ex)\n\n    def _on_device_change(self, device: Device) -&gt; None:\n        \"\"\"Update message options when device changes\"\"\"\n        try:\n            self.message_select.selection = device.messages\n            self.message_select._update_options()\n            self.details_view.content = device.as_html()\n        except Exception as ex:\n            self._handle_error(\"Error updating messages\", ex)\n\n    def _on_message_change(self, message: MBusMessage) -&gt; None:\n        \"\"\"Update display when message changes\"\"\"\n        try:\n            self.hex_input.value = message.hex\n            self.details_view.content = message.device.as_html()\n            self._parse_message()\n        except Exception as ex:\n            self._handle_error(\"Error updating message display\", ex)\n\n    def _parse_message(self) -&gt; None:\n        \"\"\"Parse the M-Bus message with comprehensive error handling\"\"\"\n        try:\n            self.json_view.content = \"\"\n            self.error_view.content = \"\"\n\n            hex_str = self.hex_input.value\n            if not hex_str:\n                raise ValueError(\"Please enter a hex message\")\n\n            error_msg, frame = self.parse_mbus_frame(hex_str)\n            if error_msg:\n                raise ValueError(error_msg)\n\n            json_str = self.get_frame_json(frame)\n            self.json_view.content = json_str\n\n        except Exception as ex:\n            self._handle_error(\"Error parsing message\", ex)\n\n    def _handle_error(self, context: str, error: Exception) -&gt; None:\n        \"\"\"Centralized error handling with user feedback\"\"\"\n        error_msg = f\"{context}: {str(error)}\"\n        self.error_view.content = f\"&lt;div class='text-red-500'&gt;{error_msg}&lt;/div&gt;\"\n        ui.notify(error_msg, type=\"negative\")\n\n        if self.solution:\n            self.solution.handle_exception(error)\n</code></pre>"},{"location":"#mbusread.mbus_viewer.MBusViewer.create_textarea","title":"<code>create_textarea(label, placeholder=None, height='h-32')</code>","text":"<p>Create a consistent textarea with error handling</p> Source code in <code>mbusread/mbus_viewer.py</code> <pre><code>def create_textarea(\n    self, label: str, placeholder: Optional[str] = None, height: str = \"h-32\"\n) -&gt; ui.textarea:\n    \"\"\"Create a consistent textarea with error handling\"\"\"\n    return (\n        ui.textarea(label=label, placeholder=placeholder)\n        .classes(f\"w-full {height}\")\n        .props(\"clearable outlined\")\n    )\n</code></pre>"},{"location":"#mbusread.mbus_viewer.MBusViewer.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Create the main UI layout with two-column design</p> Source code in <code>mbusread/mbus_viewer.py</code> <pre><code>def setup_ui(self) -&gt; None:\n    \"\"\"Create the main UI layout with two-column design\"\"\"\n    try:\n        ui.label(\"M-Bus Message Parser\").classes(\"text-2xl font-bold mb-4\")\n\n        with ui.row().classes(\"w-full gap-4\"):\n            # Left column\n            with ui.column().classes(\"flex-1\"):\n                with ui.card().classes(\"w-full\"):\n                    with ui.row().classes(\"gap-8\"):\n                        self.manufacturer_select = RadioSelection[Manufacturer](\n                            \"Manufacturer\",\n                            \"name\",\n                            selection=self.config.manufacturers,\n                        ).setup(self._on_manufacturer_change)\n\n                        self.device_select = RadioSelection[Device](\n                            \"Device\",\n                            \"model\",\n                            selection=self.manufacturer_select.item.devices,\n                        ).setup(self._on_device_change)\n\n                    # Device details\n                    with ui.card().classes(\"w-full\"):\n                        ui.label(\"Device Details\").classes(\"text-lg font-bold mb-2\")\n                        self.details_view = ui.html()\n\n                    with ui.row().classes(\"mt-4\"):\n                        self.message_select = RadioSelection[MBusMessage](\n                            \"Message\",\n                            \"name\",\n                            selection=self.device_select.item.messages,\n                        ).setup(self._on_message_change)\n\n                # Input area\n                with ui.card().classes(\"w-full mt-4\"):\n                    self.hex_input = self.create_textarea(\n                        \"Enter M-Bus hex message\",\n                        \"e.g. 68 4d 4d 68 08 00 72 26 54 83 22 77...\",\n                    )\n                    ui.button(\n                        \"Parse Message\", on_click=self._parse_message\n                    ).classes(\"mt-4\")\n\n            # Right column\n            with ui.column().classes(\"flex-1\"):\n                # Results area\n                with ui.row().classes(\"w-full\"):\n                    self.error_view = ui.html().classes(\"text-red-500\")\n                    self.json_view = ui.code(\"\", language=\"json\").classes(\n                        \"w-full h-96\"\n                    )\n\n    except Exception as ex:\n        self._handle_error(\"Error setting up UI\", ex)\n</code></pre>"},{"location":"#mbusread.mbus_viewer.RadioSelection","title":"<code>RadioSelection</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic radio button selection with type hints and improved structure</p> Source code in <code>mbusread/mbus_viewer.py</code> <pre><code>@dataclass\nclass RadioSelection(Generic[T]):\n    \"\"\"Generic radio button selection with type hints and improved structure\"\"\"\n\n    title: str\n    key_attr: str\n    selection: Dict[str, T] = field(default_factory=dict)\n    value: Optional[str] = None\n    item: Optional[T] = None\n    on_change: Optional[Callable[[T], None]] = None\n\n    def __post_init__(self):\n        self.radio = None\n        self.label = None\n        self.options = observables.ObservableDict()\n\n    def setup(\n        self, on_change: Optional[Callable[[T], None]] = None\n    ) -&gt; \"RadioSelection[T]\":\n        \"\"\"Initialize the radio selection UI components\"\"\"\n        self.on_change = on_change\n        with ui.column():\n            self.label = ui.label(self.title).classes(\"font-bold text-lg\")\n            self.options = observables.ObservableDict()\n            self._update_options()\n            self.radio = ui.radio(\n                options=list(self.options.keys()),\n                on_change=self._handle_change,\n                value=self.value,\n            ).props(\"inline dense\")\n        return self\n\n    def _update_options(self) -&gt; None:\n        \"\"\"Update radio options with error handling\"\"\"\n        try:\n            self.options.clear()\n            for i, (key, item) in enumerate(self.selection.items()):\n                value = getattr(item, self.key_attr)\n                self.options[value] = key\n                if i == 0:  # Set initial selection\n                    self.value = value\n                    self.item = item\n\n            if self.radio:\n                self.radio.clear()\n                self.radio.options = list(self.options.keys())\n                self.radio.update()\n\n        except AttributeError as e:\n            ui.notify(f\"Error updating options: {str(e)}\", type=\"negative\")\n\n    def _handle_change(self, event) -&gt; None:\n        \"\"\"Handle radio selection changes with validation\"\"\"\n        try:\n            self.value = event.value\n            key = self.options.get(self.value)\n            if key is not None:\n                self.item = self.selection[key]\n                if self.on_change:\n                    self.on_change(self.item)\n        except KeyError as e:\n            ui.notify(f\"Invalid selection: {str(e)}\", type=\"negative\")\n</code></pre>"},{"location":"#mbusread.mbus_viewer.RadioSelection.setup","title":"<code>setup(on_change=None)</code>","text":"<p>Initialize the radio selection UI components</p> Source code in <code>mbusread/mbus_viewer.py</code> <pre><code>def setup(\n    self, on_change: Optional[Callable[[T], None]] = None\n) -&gt; \"RadioSelection[T]\":\n    \"\"\"Initialize the radio selection UI components\"\"\"\n    self.on_change = on_change\n    with ui.column():\n        self.label = ui.label(self.title).classes(\"font-bold text-lg\")\n        self.options = observables.ObservableDict()\n        self._update_options()\n        self.radio = ui.radio(\n            options=list(self.options.keys()),\n            on_change=self._handle_change,\n            value=self.value,\n        ).props(\"inline dense\")\n    return self\n</code></pre>"},{"location":"#mbusread.mbus_viewer_cmd","title":"<code>mbus_viewer_cmd</code>","text":"<p>Created on 2025-01-22</p> <p>@author: wf</p>"},{"location":"#mbusread.mbus_viewer_cmd.NiceMBusCmd","title":"<code>NiceMBusCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for ngwidgets</p> Source code in <code>mbusread/mbus_viewer_cmd.py</code> <pre><code>class NiceMBusCmd(WebserverCmd):\n    \"\"\"\n    command line handling for ngwidgets\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=MBusConfig.examples_path(),\n            help=\"path to mbux hex files [default: %(default)s]\",\n        )\n        return parser\n</code></pre>"},{"location":"#mbusread.mbus_viewer_cmd.NiceMBusCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>mbusread/mbus_viewer_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=MBusConfig.examples_path(),\n        help=\"path to mbux hex files [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#mbusread.mbus_viewer_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>mbusread/mbus_viewer_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = NiceMBusCmd(\n        config=NiceMBusWebserver.get_config(),\n        webserver_cls=NiceMBusWebserver,\n    )\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#mbusread.mbus_viewer_server","title":"<code>mbus_viewer_server</code>","text":"<p>Created on 22.01.2025</p> <p>@author: wf</p>"},{"location":"#mbusread.mbus_viewer_server.NiceMBus","title":"<code>NiceMBus</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> Source code in <code>mbusread/mbus_viewer_server.py</code> <pre><code>class NiceMBus(InputWebSolution):\n    \"\"\" \"\"\"\n\n    def __init__(self, webserver: \"NiceMBusWebserver\", client: Client):\n        super().__init__(webserver, client)\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n        \"\"\"\n\n        def setup_home():\n            viewer = MBusViewer(solution=self)\n            viewer.setup_ui()\n\n        await self.setup_content_div(setup_home)\n</code></pre>"},{"location":"#mbusread.mbus_viewer_server.NiceMBus.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>mbusread/mbus_viewer_server.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n    \"\"\"\n\n    def setup_home():\n        viewer = MBusViewer(solution=self)\n        viewer.setup_ui()\n\n    await self.setup_content_div(setup_home)\n</code></pre>"},{"location":"#mbusread.mbus_viewer_server.NiceMBusWebserver","title":"<code>NiceMBusWebserver</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>webserver to demonstrate ngwidgets capabilities</p> Source code in <code>mbusread/mbus_viewer_server.py</code> <pre><code>class NiceMBusWebserver(InputWebserver):\n    \"\"\"\n    webserver to demonstrate ngwidgets capabilities\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2025 Wolfgang Fahl\"\n        config = WebserverConfig(\n            short_name=\"mbus_viewer\",\n            timeout=6.0,\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9996,\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = NiceMBus\n        return server_config\n\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n        InputWebserver.__init__(self, config=NiceMBusWebserver.get_config())\n        pass\n\n    def configure_run(self):\n        root_path = (\n            self.args.root_path if self.args.root_path else MBusConfig.examples_path()\n        )\n        self.root_path = os.path.abspath(root_path)\n        self.allowed_urls = [\n            \"https://raw.githubusercontent.com/WolfgangFahl/nicescad/main/examples/\",\n            \"https://raw.githubusercontent.com/openscad/openscad/master/examples/\",\n            self.root_path,\n        ]\n</code></pre>"},{"location":"#mbusread.mbus_viewer_server.NiceMBusWebserver.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>mbusread/mbus_viewer_server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n    InputWebserver.__init__(self, config=NiceMBusWebserver.get_config())\n    pass\n</code></pre>"},{"location":"#mbusread.version","title":"<code>version</code>","text":"<p>Created on 22.01.2025</p> <p>@author: wf</p>"},{"location":"#mbusread.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for nicegui widgets</p> Source code in <code>mbusread/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for nicegui widgets\n    \"\"\"\n\n    name = \"mbusreader\"\n    version = mbusread.__version__\n    date = \"2025-01-22\"\n    updated = \"2025-01-25\"\n    description = \"MBus message parser and JSON result viewer\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/MBus_Reader\"\n    chat_url = \"https://github.com/WolfgangFahl/mbusreader/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/mbusreader\"\n\n    license = f\"\"\"Copyright 2025 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#mbusread.yamlable","title":"<code>yamlable</code>","text":"<p>Created on 2023-12-08, Extended on 2023-16-12 and 2024-01-25</p> <p>@author: wf, ChatGPT</p> <p>Prompts for the development and extension of the 'YamlAble' class within the 'yamable' module:</p> <ol> <li>Develop 'YamlAble' class in 'yamable' module. It    should convert dataclass instances to/from YAML.</li> <li>Implement methods for YAML block scalar style and    exclude None values in 'YamlAble' class.</li> <li>Add functionality to remove None values from    dataclass instances before YAML conversion.</li> <li>Ensure 'YamlAble' processes only dataclass instances,    with error handling for non-dataclass objects.</li> <li>Extend 'YamlAble' for JSON serialization and    deserialization.</li> <li>Add methods for saving/loading dataclass instances    to/from YAML and JSON files in 'YamlAble'.</li> <li>Implement loading of dataclass instances from URLs    for both YAML and JSON in 'YamlAble'.</li> <li>Write tests for 'YamlAble' within the pyLodStorage context.     Use 'samples 2' example from pyLoDStorage     https://github.com/WolfgangFahl/pyLoDStorage/blob/master/lodstorage/sample2.py    as a reference. </li> <li>Ensure tests cover YAML/JSON serialization, deserialization,     and file I/O operations, using the sample-based approach..</li> <li>Use Google-style docstrings, comments, and type hints    in 'YamlAble' class and tests.</li> <li>Adhere to instructions and seek clarification for     any uncertainties.</li> <li>Add @lod_storable annotation support that will automatically     YamlAble support and add @dataclass and @dataclass_json      prerequisite behavior to a class</li> </ol>"},{"location":"#mbusread.yamlable.DateConvert","title":"<code>DateConvert</code>","text":"<p>date converter</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>class DateConvert:\n    \"\"\"\n    date converter\n    \"\"\"\n\n    @classmethod\n    def iso_date_to_datetime(cls, iso_date: str) -&gt; datetime.date:\n        date = datetime.strptime(iso_date, \"%Y-%m-%d\").date() if iso_date else None\n        return date\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble","title":"<code>YamlAble</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>An extended YAML handler class for converting dataclass objects to and from YAML format, and handling loading from and saving to files and URLs.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>class YamlAble(Generic[T]):\n    \"\"\"\n    An extended YAML handler class for converting dataclass objects to and from YAML format,\n    and handling loading from and saving to files and URLs.\n    \"\"\"\n\n    def _yaml_setup(self):\n        \"\"\"\n        Initializes the YamAble handler, setting up custom representers and preparing it for various operations.\n        \"\"\"\n        if not is_dataclass(self):\n            raise ValueError(\"I must be a dataclass instance.\")\n        if not hasattr(self, \"_yaml_dumper\"):\n            self._yaml_dumper = yaml.Dumper\n            self._yaml_dumper.ignore_aliases = lambda *_args: True\n            self._yaml_dumper.add_representer(type(None), self.represent_none)\n            self._yaml_dumper.add_representer(str, self.represent_literal)\n\n    def represent_none(self, _, __) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for ignoring None values in the YAML output.\n        \"\"\"\n        return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n\n    def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n        \"\"\"\n        Custom representer for block scalar style for strings.\n        \"\"\"\n        if \"\\n\" in data:\n            return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n\n    def to_yaml(\n        self,\n        ignore_none: bool = True,\n        ignore_underscore: bool = True,\n        allow_unicode: bool = True,\n        sort_keys: bool = False,\n    ) -&gt; str:\n        \"\"\"\n        Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n        and using block scalar style for strings.\n\n        Args:\n            ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n            ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n            allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n            sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n        Returns:\n            A string representation of the dataclass object in YAML format.\n        \"\"\"\n        obj_dict = asdict(self)\n        self._yaml_setup()\n        clean_dict = self.remove_ignored_values(\n            obj_dict, ignore_none, ignore_underscore\n        )\n        yaml_str = yaml.dump(\n            clean_dict,\n            Dumper=self._yaml_dumper,\n            default_flow_style=False,\n            allow_unicode=allow_unicode,\n            sort_keys=sort_keys,\n        )\n        return yaml_str\n\n    @classmethod\n    def from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n        \"\"\"\n        Deserializes a YAML string to a dataclass instance.\n\n        Args:\n            yaml_str (str): A string containing YAML formatted data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        data: dict[str, Any] = yaml.safe_load(yaml_str)\n        instance: T = cls.from_dict(data)\n        return instance\n\n    @classmethod\n    def load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML file.\n\n        Args:\n            filename (str): The path to the YAML file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            yaml_str: str = file.read()\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    @classmethod\n    def load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a YAML string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the YAML data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        yaml_str: str = cls.read_from_url(url)\n        instance: T = cls.from_yaml(yaml_str)\n        return instance\n\n    def save_to_yaml_file(self, filename: str):\n        \"\"\"\n        Saves the current dataclass instance to a YAML file.\n\n        Args:\n            filename (str): The path where the YAML file will be saved.\n        \"\"\"\n        yaml_content: str = self.to_yaml()\n        with open(filename, \"w\") as file:\n            file.write(yaml_content)\n\n    @classmethod\n    def load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON file.\n\n        Args:\n            filename (str): The path to the JSON file.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        with open(filename, \"r\") as file:\n            json_str: str = file.read()\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    @classmethod\n    def load_from_json_url(cls: Type[T], url: str) -&gt; T:\n        \"\"\"\n        Loads a dataclass instance from a JSON string obtained from a URL.\n\n        Args:\n            url (str): The URL pointing to the JSON data.\n\n        Returns:\n            T: An instance of the dataclass.\n        \"\"\"\n        json_str: str = cls.read_from_url(url)\n        instance: T = cls.from_json(json_str)\n        return instance\n\n    def save_to_json_file(self, filename: str, **kwargs):\n        \"\"\"\n        Saves the current dataclass instance to a JSON file.\n\n        Args:\n            filename (str): The path where the JSON file will be saved.\n            **kwargs: Additional keyword arguments for the `to_json` method.\n        \"\"\"\n        json_content: str = self.to_json(**kwargs)\n        with open(filename, \"w\") as file:\n            file.write(json_content)\n\n    @classmethod\n    def read_from_url(cls, url: str) -&gt; str:\n        \"\"\"\n        Helper method to fetch content from a URL.\n        \"\"\"\n        with urllib.request.urlopen(url) as response:\n            if response.status == 200:\n                return response.read().decode()\n            else:\n                raise Exception(f\"Unable to load data from URL: {url}\")\n\n    @classmethod\n    def remove_ignored_values(\n        cls,\n        value: Any,\n        ignore_none: bool = True,\n        ignore_underscore: bool = False,\n        ignore_empty: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Recursively removes specified types of values from a dictionary or list.\n        By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n        Args:\n            value: The value to process (dictionary, list, or other).\n            ignore_none: Flag to indicate whether None values should be removed.\n            ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n            ignore_empty: Flag to indicate whether empty collections should be removed.\n        \"\"\"\n\n        def is_valid(v):\n            \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n            if ignore_none and v is None:\n                return False\n            if ignore_empty:\n                if isinstance(v, Mapping) and not v:\n                    return False  # Empty dictionary\n                if (\n                    isinstance(v, Iterable)\n                    and not isinstance(v, (str, bytes))\n                    and not v\n                ):\n                    return (\n                        False  # Empty list, set, tuple, etc., but not string or bytes\n                    )\n            return True\n\n        if isinstance(value, Mapping):\n            value = {\n                k: YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for k, v in value.items()\n                if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n            }\n        elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n            value = [\n                YamlAble.remove_ignored_values(\n                    v, ignore_none, ignore_underscore, ignore_empty\n                )\n                for v in value\n                if is_valid(v)\n            ]\n        return value\n\n    @classmethod\n    def from_dict2(cls: Type[T], data: dict) -&gt; T:\n        \"\"\"\n        Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n        \"\"\"\n        if not data:\n            return None\n        instance = from_dict(data_class=cls, data=data)\n        return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.from_dict2","title":"<code>from_dict2(data)</code>  <code>classmethod</code>","text":"<p>Creates an instance of a dataclass from a dictionary, typically used in deserialization.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef from_dict2(cls: Type[T], data: dict) -&gt; T:\n    \"\"\"\n    Creates an instance of a dataclass from a dictionary, typically used in deserialization.\n    \"\"\"\n    if not data:\n        return None\n    instance = from_dict(data_class=cls, data=data)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.from_yaml","title":"<code>from_yaml(yaml_str)</code>  <code>classmethod</code>","text":"<p>Deserializes a YAML string to a dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_str</code> <code>str</code> <p>A string containing YAML formatted data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef from_yaml(cls: Type[T], yaml_str: str) -&gt; T:\n    \"\"\"\n    Deserializes a YAML string to a dataclass instance.\n\n    Args:\n        yaml_str (str): A string containing YAML formatted data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    data: dict[str, Any] = yaml.safe_load(yaml_str)\n    instance: T = cls.from_dict(data)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.load_from_json_file","title":"<code>load_from_json_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON file.\n\n    Args:\n        filename (str): The path to the JSON file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        json_str: str = file.read()\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.load_from_json_url","title":"<code>load_from_json_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a JSON string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the JSON data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef load_from_json_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a JSON string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the JSON data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    json_str: str = cls.read_from_url(url)\n    instance: T = cls.from_json(json_str)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.load_from_yaml_file","title":"<code>load_from_yaml_file(filename)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_file(cls: Type[T], filename: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML file.\n\n    Args:\n        filename (str): The path to the YAML file.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    with open(filename, \"r\") as file:\n        yaml_str: str = file.read()\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.load_from_yaml_url","title":"<code>load_from_yaml_url(url)</code>  <code>classmethod</code>","text":"<p>Loads a dataclass instance from a YAML string obtained from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL pointing to the YAML data.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>An instance of the dataclass.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef load_from_yaml_url(cls: Type[T], url: str) -&gt; T:\n    \"\"\"\n    Loads a dataclass instance from a YAML string obtained from a URL.\n\n    Args:\n        url (str): The URL pointing to the YAML data.\n\n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    yaml_str: str = cls.read_from_url(url)\n    instance: T = cls.from_yaml(yaml_str)\n    return instance\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.read_from_url","title":"<code>read_from_url(url)</code>  <code>classmethod</code>","text":"<p>Helper method to fetch content from a URL.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef read_from_url(cls, url: str) -&gt; str:\n    \"\"\"\n    Helper method to fetch content from a URL.\n    \"\"\"\n    with urllib.request.urlopen(url) as response:\n        if response.status == 200:\n            return response.read().decode()\n        else:\n            raise Exception(f\"Unable to load data from URL: {url}\")\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.remove_ignored_values","title":"<code>remove_ignored_values(value, ignore_none=True, ignore_underscore=False, ignore_empty=True)</code>  <code>classmethod</code>","text":"<p>Recursively removes specified types of values from a dictionary or list. By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to process (dictionary, list, or other).</p> required <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether keys starting with an underscore should be removed.</p> <code>False</code> <code>ignore_empty</code> <code>bool</code> <p>Flag to indicate whether empty collections should be removed.</p> <code>True</code> Source code in <code>mbusread/yamlable.py</code> <pre><code>@classmethod\ndef remove_ignored_values(\n    cls,\n    value: Any,\n    ignore_none: bool = True,\n    ignore_underscore: bool = False,\n    ignore_empty: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Recursively removes specified types of values from a dictionary or list.\n    By default, it removes keys with None values. Optionally, it can also remove keys starting with an underscore.\n\n    Args:\n        value: The value to process (dictionary, list, or other).\n        ignore_none: Flag to indicate whether None values should be removed.\n        ignore_underscore: Flag to indicate whether keys starting with an underscore should be removed.\n        ignore_empty: Flag to indicate whether empty collections should be removed.\n    \"\"\"\n\n    def is_valid(v):\n        \"\"\"Check if the value is valid based on the specified flags.\"\"\"\n        if ignore_none and v is None:\n            return False\n        if ignore_empty:\n            if isinstance(v, Mapping) and not v:\n                return False  # Empty dictionary\n            if (\n                isinstance(v, Iterable)\n                and not isinstance(v, (str, bytes))\n                and not v\n            ):\n                return (\n                    False  # Empty list, set, tuple, etc., but not string or bytes\n                )\n        return True\n\n    if isinstance(value, Mapping):\n        value = {\n            k: YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for k, v in value.items()\n            if is_valid(v) and (not ignore_underscore or not k.startswith(\"_\"))\n        }\n    elif isinstance(value, Iterable) and not isinstance(value, (str, bytes)):\n        value = [\n            YamlAble.remove_ignored_values(\n                v, ignore_none, ignore_underscore, ignore_empty\n            )\n            for v in value\n            if is_valid(v)\n        ]\n    return value\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.represent_literal","title":"<code>represent_literal(dumper, data)</code>","text":"<p>Custom representer for block scalar style for strings.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>def represent_literal(self, dumper: yaml.Dumper, data: str) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for block scalar style for strings.\n    \"\"\"\n    if \"\\n\" in data:\n        return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data, style=\"|\")\n    return dumper.represent_scalar(\"tag:yaml.org,2002:str\", data)\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.represent_none","title":"<code>represent_none(_, __)</code>","text":"<p>Custom representer for ignoring None values in the YAML output.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>def represent_none(self, _, __) -&gt; yaml.Node:\n    \"\"\"\n    Custom representer for ignoring None values in the YAML output.\n    \"\"\"\n    return self._yaml_dumper.represent_scalar(\"tag:yaml.org,2002:null\", \"\")\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.save_to_json_file","title":"<code>save_to_json_file(filename, **kwargs)</code>","text":"<p>Saves the current dataclass instance to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the JSON file will be saved.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the <code>to_json</code> method.</p> <code>{}</code> Source code in <code>mbusread/yamlable.py</code> <pre><code>def save_to_json_file(self, filename: str, **kwargs):\n    \"\"\"\n    Saves the current dataclass instance to a JSON file.\n\n    Args:\n        filename (str): The path where the JSON file will be saved.\n        **kwargs: Additional keyword arguments for the `to_json` method.\n    \"\"\"\n    json_content: str = self.to_json(**kwargs)\n    with open(filename, \"w\") as file:\n        file.write(json_content)\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.save_to_yaml_file","title":"<code>save_to_yaml_file(filename)</code>","text":"<p>Saves the current dataclass instance to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path where the YAML file will be saved.</p> required Source code in <code>mbusread/yamlable.py</code> <pre><code>def save_to_yaml_file(self, filename: str):\n    \"\"\"\n    Saves the current dataclass instance to a YAML file.\n\n    Args:\n        filename (str): The path where the YAML file will be saved.\n    \"\"\"\n    yaml_content: str = self.to_yaml()\n    with open(filename, \"w\") as file:\n        file.write(yaml_content)\n</code></pre>"},{"location":"#mbusread.yamlable.YamlAble.to_yaml","title":"<code>to_yaml(ignore_none=True, ignore_underscore=True, allow_unicode=True, sort_keys=False)</code>","text":"<p>Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables, and using block scalar style for strings.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_none</code> <code>bool</code> <p>Flag to indicate whether None values should be removed from the YAML output.</p> <code>True</code> <code>ignore_underscore</code> <code>bool</code> <p>Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.</p> <code>True</code> <code>allow_unicode</code> <code>bool</code> <p>Flag to indicate whether to allow unicode characters in the output.</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>Flag to indicate whether to sort the dictionary keys in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the dataclass object in YAML format.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>def to_yaml(\n    self,\n    ignore_none: bool = True,\n    ignore_underscore: bool = True,\n    allow_unicode: bool = True,\n    sort_keys: bool = False,\n) -&gt; str:\n    \"\"\"\n    Converts this dataclass object to a YAML string, with options to omit None values and/or underscore-prefixed variables,\n    and using block scalar style for strings.\n\n    Args:\n        ignore_none: Flag to indicate whether None values should be removed from the YAML output.\n        ignore_underscore: Flag to indicate whether attributes starting with an underscore should be excluded from the YAML output.\n        allow_unicode: Flag to indicate whether to allow unicode characters in the output.\n        sort_keys: Flag to indicate whether to sort the dictionary keys in the output.\n\n    Returns:\n        A string representation of the dataclass object in YAML format.\n    \"\"\"\n    obj_dict = asdict(self)\n    self._yaml_setup()\n    clean_dict = self.remove_ignored_values(\n        obj_dict, ignore_none, ignore_underscore\n    )\n    yaml_str = yaml.dump(\n        clean_dict,\n        Dumper=self._yaml_dumper,\n        default_flow_style=False,\n        allow_unicode=allow_unicode,\n        sort_keys=sort_keys,\n    )\n    return yaml_str\n</code></pre>"},{"location":"#mbusread.yamlable.lod_storable","title":"<code>lod_storable(cls)</code>","text":"<p>Decorator to make a class LoDStorable by inheriting from YamlAble. This decorator also ensures the class is a dataclass and has JSON serialization/deserialization capabilities.</p> Source code in <code>mbusread/yamlable.py</code> <pre><code>def lod_storable(cls):\n    \"\"\"\n    Decorator to make a class LoDStorable by\n    inheriting from YamlAble.\n    This decorator also ensures the class is a\n    dataclass and has JSON serialization/deserialization\n    capabilities.\n    \"\"\"\n    cls = dataclass(cls)  # Apply the @dataclass decorator\n    cls = dataclass_json(cls)  # Apply the @dataclass_json decorator\n\n    class LoDStorable(YamlAble, cls):\n        \"\"\"\n        decorator class\n        \"\"\"\n\n        __qualname__ = cls.__qualname__\n        pass\n\n    LoDStorable.__name__ = cls.__name__\n    LoDStorable.__doc__ = cls.__doc__\n\n    return LoDStorable\n</code></pre>"}]}